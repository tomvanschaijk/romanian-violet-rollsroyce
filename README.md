Firstly, this solution uses dotnetcore 3.0, so do make sure you have all the obviously required installations on your end to be able to debug and play around with this application. I would say https://visualstudio.microsoft.com/vs/ and https://dotnet.microsoft.com/download/dotnet-core/3.0 are good locations to visit for that.

To run the project, start both the API and the Web application. The API has 5 basic endpoints:
* a GET to monitoring/alive which serves as a basic heartbeat check
* a GET to monitoring/health which is the healthcheck functionality offered since dotnetcore 2.2. This one just offers a simple memory health check, since the API has no other external dependencies. It would make sense to also add a healthcheck to the Blazor Server web application, in which the alive endpoint of the API could be called (not the health endpoint, we don't want to cause a cascading effect of healthcheck calls). The implementation of healthchecks in Blazor Server seems to be a bit different though, since adding it in the "normal" way causes an issue with the routing. Consider this "under construction" until I find out what the way to go here is.
* a POST to api/accounts/ in order to create a new account for a customerId and initialCredit (both sent in the body). If the initialCredit is not 0, a first transaction is created for the account.
* a POST to api/accounts/{accountId}/transactions to create a new transaction for the given account. The body consists of the amount, which could be positive or negative, with an obvious effect to the account balance. There is no business logic in place restricting going in the negative.
* a GET to api/customers/accountdata which returns a combination a customer/account/transaction data. Maybe not quite a RESTfull endpoint (maybe I should change this to api/accountdata..?). This is the only call that is used by the Web application.

All responses are returned in a format that is (pretty close) to the JSON API conventions as described here https://jsonapi.org/. I may have diverged from that slightly though, and do not use all available fields, since the API is rather limited currently. In the Postman folder, a collection is present in order to explore the available api endpoints. Simply import this file into Postman and you can play around with the above endpoints (examples are provided), or simply use the Postman Runner to call all endpoints in order and inspect the results (make sure to switch off SSL certificate verification in Postman). All that will happen with the given examples is that an extra account is created, with a first transaction for another customer, as well as a new transaction for the already seeded account. Lastly, the api/customers/accountdata call is performed to show you the result of all the previous actions.

The Blazor Server web application only serves to show an overview of the entered customers with their respective accounts and the transactions performed on those accounts. There is no real back-end present; although the repositories are in place, all that is happening is storing the customers, accounts and transactions in memory. During startup of the API, a minimal amount of seeding is done: 3 customers and 1 account with 1 transaction is created. This will immediately be visible in the Web application.

The branching strategy used is the Gitflow strategy as described on https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow

Basic logging is done using Serilog. In the API this is working just fine, but in the Blazor Server application, I'm running into a temporary problem where the injection of the correlationId from the header (if it is sent in) into the RequestContext is not being done, due to the Middleware for that not being called in the pipeline. This of course has something to do with the way Blazor Server works. I must say this is my first project using Blazor Server, so I'll have to look around to see how I make sure the Middleware pipeline is being called whenever I hit Refresh (and thus, go back to the server). Let's call it "ongoing".

By the way, I got a good remark about injecting the IServiceFactory in the API controllers. For sure, you don't need to inject a factory there. The implementation in this factory is also just digging in the ServiceProvider and returning what's in there. I guess I just snuck it in here for giggles and to show it "could" be done. Realistically though, you would only ever take this approach if the amount of services inside of your controller is so big that injecting them separately is cumbersome and leading to a bloated constructor. In that case, however, you could argue that the design of your controller is doubtful and it may be doing too much... So in short: in any production system with good design, this approach could indicate some problems, and the "usual" approach would just be to inject the few services that a controller needs directly into that controller.
