To run the project, start both the API and the Web application. The API has 5 basic endpoints:
* a GET to monitoring/alive which serves as a basic heartbeat check
* a GET to monitoring/health which is the healthcheck functionality offered since dotnetcore 2.2. This one just offers a simple memory health check. since the API has no other external dependencies. It would make sense to also add a healthcheck to the Blazor Server web application, in which the alive endpoint of the API could be called (not the health endpoint, we don't want to cause a cascading effect of healthcheck calls). The implementation of healthchecks in Blazor Server seems to be a bit different though, since adding it in the "normal" way causes an issue with the routing. Consider this "under construction" until I find out what the way to go here is.
* a POST to api/accounts/ in order to create a new account for a customerId and initialCredit (both served up in the body). If the initialCredit is not 0, a first transaction is created for the account.
* a POST to api/accounts/{accountId}/transactions to create a new transaction for the given account. The body consists of the amount, which could be positive or negative, with the obvious effect to the account balance. There is no business logic in place restricting going in the negative.
* a GET to api/customers/accountdata which returns a combination a customer/account/transaction data. Maybe not quite a fully REST endpoint (maybe I should change this to api/accountdata..?). This is the only call that is used by the Web application.

All responses are returned in a format that is (pretty close) to the JSON API conventions as described here https://jsonapi.org/. I may have diverged from that slightly though, and do not use all available fields, since the API is rather limited currently. In the Postman folder, a collection is present in order to explore the available api endpoints. Simply import this file into Postman in order to play around with the above endpoints (examples are provided), or simply use the Postman Runner to call all endpoints in order and inspect the result. All that will happen with the given examples is create an extra account with a first transaction for another customer, as well as a new transaction for the already seeded account. Lastly, the api/customers/accountdata call is done to show you the result of all the previous.

The Blazor Server web application only serves to show an overview of the entered customers with their respective accounts and the transactions performed on those accounts. There is no real back-end present; although the repositories are in place, all that is happening is storing the customers, accounts and transactions in memory. During startup of the API, a minimal amount of seeding is done: 3 customers and 1 account with 1 transaction is created. This will immediately be visible in the Web application.

The branching strategy used is the Gitflow strategy as described on https://www.atlassian.com/git/tutorials/comparing-workflows/gitflow-workflow
